Контролно 2:
1.	Обяснете понятието „дефиниране на функция на функционално ниво“. Дайте пример за дефиниция на функция на функционално ниво.
Дефинирането на някаква функция на функционално ниво предполага действието на тази функция да се опише не в термините на резултата, който връща тя при прилагане към подходящо множество от аргументи, а като директно се посочи връзката ѝ с други функции. Например, ако вече са дефинирани функциите
f :: b -> c   и
g :: a -> b , то тяхната композиция fxg – функцията, за която е изпълнено
(fxg f g) x = (f . g) x = f (g x) за всяко x от тип a, може да се дефинира с използване на вградения оператор ‘.’ от тип (.) :: (b -> c) -> (a -> b) -> (a -> c) както следва: fxg f g = (f . g)
2.	Характеризирайте накратко структурата от данни „опашка“.
Логическо описание: Опашката е крайна редица от елементи от един и същ тип. Операцията включване на елемент е допустима само за единия (например десния) край на редицата, който се нарича край на опашката. Операцията изключване на елемент е допустима само за другия (левия) край на редицата, който се нарича начало на опашката. Възможен е пряк достъп само до елемента, намиращ се в началото на опашката. При описаната организация на логическите операции, последният включен в опашката елемент се изключва последен, а първият – първи. Затова опашката се определя още като структура от данни „пръв влязъл – пръв излязъл“ (first in – first out, FIFO)
Физическо представяне: Аналогично на стека, при опашката се използват два основни начина за физическо представяне: последователно и свързано. При последователното представяне се запазва блок от паметта, вътре в който опашката да расте и да се съкращава. Свързаното представяне на една опашка е аналогично на това на стека, но се добавя още и указател към последния елемент на опашката.
3.	Опишете накратко стратегията за търсене на път в граф в дълбочина (depth-first search):
При търсенето в дълбочина фронтът се обработва като стек: • В началото на търсенето фронтът има вида [[Start]]. • Ако на текущата стъпка фронтът е празен ([ ]), търсенето се прекратява и се връща [ ] (индикация за липса на решение). • Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то: o избира се първият елемент на фронта (p1); o ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат; o ацикличните пътища p1', p1" , … , p1(k), които продължават с една дъга p1, се добавят в началото на стека (преди p2), т.е. фронтът придобива вида [p1', p1'', … , p1(k), p2, ... , pn] и се преминава към следващата стъпка; o p2 се обработва едва след като се изследват всички пътища, които са продължения на p1.
4.	Обяснете понятието „алгебричен тип“ в езика Haskell. Дайте два примера за дефиниции на различни видове алгебрични типове.
Алгебричните типове са съставни типове данни, дефинирани от програмиста. Дефиницията на един алгебричен тип започва с ключовата дума data, след която се записват името на типа, знак за равенство и конструкторите на типа. Името на типа и имената на конструкторите задължително започват с главни букви. Най-простата разновидност на алгебричен тип се дефинира чрез изброяване на елементите на типа. Пример 1: data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
Вместо използването на вектори можем да дефинираме тип с определен брой компоненти като алгебричен тип. Такива типове често се наричат производни типове (резултатни типове; product types). Пример2:
data People = Person Name Age
Тук Name е синоним на String, а Age е синоним на Int:
type Name = String
type Age = Int
5.	Дайте пример за дефиниция на алгебричен тип като производен екземпляр на множество класове. Обяснете накратко значението на тази дефиниция.
Възможно е да се дефинира нов алгебричен тип като например Season или Shape, който да бъде екземпляр на множество вградени класове. Примерни дефиниции от посочения вид:
data Season = Spring | Summer | Autumn | Winter
 deriving (Eq,Ord,Enum,Show,Read)
data Shape = Circle Float |
 Rectangle Float Float
 deriving (Eq,Show,Read)
За да може да се дефинира един клас, е необходимо да се избере (зададе) неговото име и да се опишат ограниченията, които трябва да удовлетворява даден тип a, за да принадлежи на този клас. Типовете, които принадлежат на даден клас, се наричат екземпляри на този клас. Най-важно (определящо) за класа Eq е наличието на функцията == от тип a -> a -> Bool, която проверява дали два елемента на даден тип a, който е екземпляр на Eq, са равни: class Eq a where (==) :: a -> a -> Bool
Примерни дефиниции на функции върху екземпляри на Eq
allEqual :: Eq a => a -> a -> a -> Bool
allEqual m n p = (m==n) && (n==p)
elem :: Eq a => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = (x == y) || (elem x ys)
6.	Обяснете понятието „полиморфна функция“. Дайте два примера за полиморфни функции в езика Haskell.
Полиморфна функция е тази функция, която работи за всеки възможен тип, който се приема.
        - example1: id
        - example2: head, last, init
    What about generic functions?
        - example1: write a function in task00.hs that has Eq, Ord as constraints
        - example2 (two built-in functions): length, foldl, (+)
Една полиморфна функция, например length (намиране на дължина на списък, чийто елементи могат да бъдат от произволен тип), има единствена дефиниция, която работи върху всички нейни типове.
7.	Как се дефинират класове в Haskell? Дайте пример за дефиниция на клас:
За да може да се дефинира един клас, е необходимо да се избере (зададе) неговото име и да се опишат ограниченията, които трябва да удовлетворява даден тип a, за да принадлежи на този клас. Типовете, които принадлежат на даден клас, се наричат екземпляри на този клас. Най-важно (определящо) за класа Eq е наличието на функцията == от тип a -> a -> Bool, която проверява дали два елемента на даден тип a, който е екземпляр на Eq, са равни: class Eq a where (==) :: a -> a -> Bool
Примерни дефиниции на функции върху екземпляри на Eq
allEqual :: Eq a => a -> a -> a -> Bool
allEqual m n p = (m==n) && (n==p)
elem :: Eq a => a -> [a] -> Bool
elem _ [] = False
elem x (y:ys) = (x == y) || (elem x ys)
8.	Обяснете същността на „мързеливото“ оценяване (lazy evaluation). Дайте поне два примера, които илюстрират различни аспекти на „мързеливото“ оценяване.
„Мързеливото“ оценяване (lazy evaluation) е стратегия на оценяване, която по стандарт стои в основата на работата на всички интерпретатори на Haskell. Същността на тази стратегия е, че интерпретаторът оценява даден аргумент на дадена функция само ако (и доколкото) стойността на този аргумент е необходима за пресмятането на целия резултат. Нещо повече, ако даден аргумент е съставен (например е вектор или списък), то се оценяват само тези негови компоненти, чиито стойности са необходими от гледна точка на получаването на резултата. При това дублиращите се подизрази се оценяват по не повече от един път. Най-важно от гледна точка на оценяването на изрази в Haskell е прилагането на функции. Основната идея тук е еквивалентна на т. нар. оценяване чрез заместване в „традиционните“ езици за функционално програмиране. Оценяването на израз, който е обръщение към функцията f с аргументи a1, a2, … , ak, се състои в заместване на формалните параметри (променливите от образците, които играят ролята на формални параметри) от дефиницията на f съответно с изразите a1, a2, … , ak (или със съответните техни компоненти) и оценяване на така получения частен случай на тялото на дефиницията. 
Пример 1:
Ако например дефинираме
g x y = x + 12 , то
g (9-3) (g 34 3)
 (9-3) + 12
 6 + 12
 18   -- Тук x се замества с (9-3), но y не участва в дясната страна на равенството, определящо стойността на g, следователно аргументът (g 34 3) не се оценява. Така демонстрирахме едно от преимуществата на „мързеливото“ оценяване: аргументи, които не са необходими, не се оценяват
Пример 2:
switch :: Int -> a -> a -> a
switch n x y
 | n>0 = x
 | otherwise = y  --- Ако цялото число n е положително, резултатът съвпада с оценката на x; в противен случай той съвпада с оценката на y. С други думи, винаги при оценяване на обръщение към функцията switch се оценяват аргументът n (т.е. първият аргумент) и точно един от останалите аргументи.
Пример 3:
Нека сега функцията h е дефинирана както следва:
h :: Int -> Int -> Int
h x y = x + x
Тогава
h (9-3) (h 34 3)
 (9-3) + (9-3)
 6 + 6
 12    --- Изглежда, че в последния пример аргументът (9-3) се оценява двукратно, но принципите на „мързеливото“ оценяване гарантират, че дублираните аргументи (т.е. многократните включвания на аргументи) се оценяват по не повече от един път.


