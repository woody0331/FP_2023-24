1. Дефинирайте функция на езика Haskell, която генерира итеративен изчислителен процес. Обяснете каква задача
се решава с помощта на тази функция. // или итеративен
    Definition:
Процесите от първия тип се наричат рекурсивни.
При тях се поражда верига от обръщения към дефинираната функция с все по-прости в определен конкретен смисъл стойностина аргументите, докато се стигне до обръщение с т. нар. базов (прост, граничен) вариант на стойности на аргументите, след което започва последователно пресмятане на генерираните вече обръщения. 
Процесите от втория тип се наричат итеративни.
При тях във всеки момент състоянието на пресмятанията се описва (като при това може при необходимост да бъде прекъснато и после - възстановено) от няколко променливи (state variables, променливи на състоянието) и правило, с чиято помощ се извършва преходът от дадено състояние към следващото.
 
Example:
fibRec :: Int -> Int
fibRec 0 = 0
fibRec 1 = 1
fibRec n = fibRec (n - 2) + fibRec (n - 1)
 
fibIter :: Int -> Int
fibIter n = helper 0 1 n
 where
    helper :: Int -> Int -> Int -> Int
    helper n0 _ 0 = n0
    helper n0 n1 1 = n1
    helper n0 n1 leftover = helper n1 (n0 + n1) (leftover - 1)
 
2. Опишете общия вид на дефиниция на функция с условия (guards) в езика Haskell и процеса на оценяване на
обръщение към такава функция.
 
Програмиране на условия (guards)
Условието („охраняващ“ израз, guard) е Булев израз. Условия се използват, когато трябва да се опишат различни случаи в дефиницията на функция.
Общ вид на дефиниция на функция с условия:
име на функцията
„формални параметри“ (образци)
условия
различни изрази, определящи резултата (в зависимост от условията)
 name x1 x2 … xk 
 | g1 = e1 
 | g2 = e2 
 …..
 | otherwise = e
 
Когато трябва да се приложи дадена функция към дадено множество от изрази (стойности на съответните аргументи), е необходимо да се установи кой от поредните случаи в дефиницията на функцията е приложим.
За да се отговори на този въпрос, трябва последователно да се оценят охраняващите изрази (условията), докато се достигне до първия срещнат, чиято оценка е True. Съответният израз от дясната страна на равенството определя резултата.
 
3. Как се конструира списък чрез техниката на определяне на неговия обхват (list comprehension) в езика Haskell?
Обяснете общия случай и дайте поне два примера (в т.ч. посочете оценките на изразите от Вашите примери).
Дефиниране на списък чрез определяне на неговия обхват
(List Comprehension)
Синтаксис:
[expr | q1, … , qk] , където expr е израз, а qi може да бъде 
- генератор от вида p <- lExp, където p е образец и lExp е израз от списъчен тип
- тест (филтър), bExp, който е булев израз
При това в qi могат да участват променливите, използвани в q1,
q2, … , qi-1
Пример 1: [2*n | n <- ex]
Пример 2: [2*n | n <- ex, isEven n, n>3]
 
 
4. Кои от следните конструкции са коректно дефинирани (валидни) списъци в Haskell? Посочете типовете на
валидните списъци, а за останалите обяснете защо не са валидни.
 
    (а) [”A”,’A’]
    (б) [[],[[1,2,3],[]]]
    (в) [(345,”Hello”),(3456,”Hello”,”World”)]
    (г) [[”123”,”Hello”],[”1245”,”Hello”,”World”]]
 
    Answer(s):
        a <= не е валидно. Причина: списъкът е хомогенна структура
        б <= Num a => [[[a]]]
        в <= не е валидно. Причина: списъкът е хомогенна структура
        г <= [[String]]
 
5. Дайте пример за дефиниция на функция на Haskell, в която се използва обща (а не примитивна) рекурсия върху списъци.
Обяснете каква задача се решава с помощта на тази функция.
Обща рекурсия:
myZip :: [a] -> [b] -> [(a, b)]
myZip [] _ = []
myZip _ [] = []
myZip (x:xs) (y:ys) = (x, y) : myZip xs ys
Примитивна рекурсия:
mySum :: (Num a) => [a] -> a
mySum [] = 0
mySum (x:xs) = x + mySum xs
 
    Primitive:
        Only one list
        AND The base is the empty list
        AND The recursive call works with the tail of the list.
 
    General:
        Many two lists
        OR The base does not depend on the list(s)
        OR There is more than one call to the function.
 
6. Обяснете действието на функцията foldr в езика Haskell. Дайте поне два примера.
Разглежданата функция може да бъде модифицирана така, че да получава един допълнителен аргумент, който определя стойността, която следва да се върне при опит за комбиниране по зададеното правило на елементите на празния списък.
Новополучената функция се нарича foldr (което означава fold, т.е. комбиниране/акумулиране, извършено чрез групиране от дясно – bracketing to the right).
Дефиниция на функцията foldr:
foldr :: (a -> a -> a) -> a -> [a] -> a
binary operation 	starting value 	list of values	 the result
over type a 		of type a 		to be combined 	 of type a
Забележки:
1. В действителност типът на функцията foldr е по-общ:
foldr :: (a -> b -> b) -> b -> [a] -> b
2. В стандартната прелюдия на Haskell е включена и функция foldl, която е подобна на foldr, но осъществява комбиниране/акумулиране, извършено чрез групиране от ляво – bracketing to the left.
 
foldr (*) 0 [1, 2, 3] => 0
foldr (+) 0 [1, 2, 3]
    acc=0 x=3 => ??? + ??? => 1 + (2 + (3 + 0))
foldl (+) 0 [1, 2, 3]
    acc=0 x=1 => ((0 + 1) + 2) + 3
 
7. Обяснете понятието "оператор" в езика Haskell. Какви свойства имат операторите? Дайте пример за дефиниция на
оператор, придружена от спецификация на неговите свойства.
Дефиниция и свойства на операторите:
Операторите в Haskell са инфиксни функции, т.е. такива (двуаргументни) функции, означенията на които се записват между
аргументите им, а не преди тях.
Операторите имат две важни свойства – техните приоритет (сила на свързването, binding power) и асоциативност.
Приоритетът е свойство на операторите, което определя реда на изпълнение на поредица от различни оператори.
Например в аритметиката операциите (операторите) умножение и деление имат по-висок приоритет от събирането и изваждането, а степенуването има по-висок приоритет от умножението и делението.
В Haskell всеки (вграден) оператор има своя сила на свързването (binding power) – цяло неотрицателно число (цяло число между 0 и 9), което определя неговия приоритет.
Асоциативността е свойство на операторите, което определя реда на изпълнение на поредица от еднакви оператори.
Например в аритметиката операциите (операторите) събиране и умножение са асоциативни, т.е. редът на изпълнение на поредица от събирания и умножения е без значение:
(a + b) + c = a + (b + c),
т.е. записът a + b + c може да се интерпретира еднозначно;
(a * b) * c = a * (b * c),
т.е. записът a * b * c може да се интерпретира еднозначно.
Пример:
infixr 7 >:
 
(>:) :: [a] -> a -> [a]
xs >: x = xs ++ [x]
 
8. Обяснете понятието „образец“ (pattern) в Haskell. Дайте примери за поне три типа образци и формулирайте
правилата за успешното им съпоставяне със съответните аргументи.
Образецът е езикова конструкция, с помощта на която се описва в обобщен вид отделен възможен случай за даден аргумент. В ролята на образец може да се използва:
• Литерал като например 24, ‘f’ или True; даден аргумент се съпоставя успешно с такъв образец, ако е равен на неговата стойност;
• Променлива като например x или longVariableName; образец от този вид се съпоставя успешно с аргумент с произволна стойност;
• Специален символ за безусловно съпоставяне (wildcard) ‘_’, който е съпоставим с произволен аргумент;
• Вектор – образец (p1,p2, … ,pn); за да бъде съпоставим с него, аргументът трябва да има вида (v1,v2, … ,vn), като всяко vi трябва да бъде съпоставимо със съответното pi;
• Конструктор, приложим към даденото множество от аргументи.
Примери:
 		Literal     : True, 1, False, "Hello"
        Variable    : x, y z, number
        Wildcard    : _
        Tuple       : (x, y, z)
        Constructor1 : []
        Constructor2 : (x:xs)
        Constructor3 : [x]
        Constructor4 : [x, y]