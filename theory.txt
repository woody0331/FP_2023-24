Теория К2- Хаскел
1.	Структура от данни-  се разбира организирана информация, която може да бъде описана, създадена и обработена с помощта на компютърна програма (Майер и Бодуен)
За да се определи една структура от данни, е необходимо да се зададат: 
• логическото описание на структурата, което описва тази структура на базата на декомпозицията ѝ на по-прости структури (компоненти), основните операции над структурата и декомпозицията на основните операции на по-прости операции; 
• физическото представяне на структурата, което дава методи за представяне на тази структура в паметта на компютъра.
2.	Важна операция над коя да е структура от данни е операцията достъп до компонентите на структурата. Тази операция е тясно свързана с физическото представяне на структурата от данни. На базата на тази операция структурите от данни се класифицират като прости и съставни:
Прости са тези структури от данни, за които операцията достъп се осъществява до структурата като цяло. Такива структури са числата, символните (знаковите) и булевите данни. Обикновено на всяка от тези структури в езиците за програмиране съответстват вградени типове данни.
Съставни са тези структури от данни, за които операцията достъп се осъществява до компонентите (елементите) на структурата, а не до структурата като цяло. Такива структури са масивът, записът, списъкът (т. нар. свързан списък), опашката, стекът и др. Съставните структури от данни се делят на статични и динамични:
	Съставна структура от данни, която се състои от фиксиран брой елементи и за която не са допустими операциите включване и изключване на елемент, се нарича статична. За статичните структури от данни в паметта на компютъра се отделя фиксирано количество памет. Такива структури са масивът и записът.
	Съставна структура от данни, която се състои от променлив брой елементи и за която са допустими операциите включване и изключване на елемент, се нарича динамична. Такива структури са стекът, опашката, дървото, графът и др.
3.	Структура от данни масив:
-	Логическо описание на масив: Масивът е крайна редица от фиксиран брой елементи от един и същ тип. Към всеки елемент от редицата е възможен пряк достъп, който се осъществява чрез индекс. Операциите включване и изключване на елемент от масив са недопустими, т.е. масивът е статична структура. 
-	Физическо представяне: Елементите на масива се записват последователно в оперативната памет. За всеки елемент от редицата се отделя фиксирано количество памет.
4.	Структура от данни запис:
-	Логическо описание: Записът е крайна редица от фиксиран брой елементи, които могат да са от различни типове. Възможен е пряк достъп до всеки елемент от редицата, който се осъществява чрез име. Елементите на редица, представляваща запис, се наричат полета на записа. Операциите включване и изключване на елемент са недопустими, т.е. структурата е статична. 
-	Физическо представяне: Полетата на записа се записват последователно в паметта на компютъра.
5.	Структура от данни множество:
-	Логическо описание: Множеството е съвкупност от елементи от един и същ тип. Операциите включване и изключване на елемент са допустими. Възможен е достъп както до отделните компоненти на множеството, така и до структурата като цяло. Достъпът е пряк. 
-	Физическо представяне: Използва се последователно представяне на структурата в паметта. За целта за всеки допустим елемент се посочва дали принадлежи или не принадлежи на множеството.
6.	Структура от данни свързан списък:
-	Логическо описание: Свързаният списък е крайна редица от елементи от един и същ тип. Операциите включване и изключване на елемент са допустими в произволно място на редицата. Възможен е достъп до всеки елемент на списъка, като достъпът до първия елемент е пряк, а до останалите елементи – последователен.
-	Физическо представяне Тъй като операциите включване и изключване на елемент са възможни на произволно място в списъка, най-естествено е свързаното физическо представяне на списък. Съществуват различни форми на свързано представяне. Най-често се използват: • свързано представяне с една връзка; • свързано представяне с две връзки.
7.	Структура от данни стек:
-	Логическо описание: Стекът е крайна редица от елементи от един и същ тип. Операциите включване и изключване на елемент са допустими само за единия край на редицата, който се нарича връх на стека. Възможен е достъп само до елемента, намиращ се на върха на стека, при това достъпът е пряк.
Примери: 1) Ако редицата a1, a2, … , an е стек с връх a1, включването на елемент a от тип, съвпадащ с типа на елементите на стека, води до получаването на нов стек, на върха на който е елементът а, т.е. a, a1, a2, … , an. 2) Ако редицата a1, a2, … , an е стек с връх a1, изключването на елемент (елемента от върха на стека) води до получаването на стека a2, … , an.
-	Физическо представяне: Широко се използват два основни начина за физическо представяне на стек: последователно и свързано. При последователното представяне се запазва блок от паметта, вътре в който стекът да расте и да се съкращава. Свързаното представяне на стека е аналогично на свързаното представяне на списък с една връзка.
8.	Структура от данни опашка:
-	Логическо описание: Опашката е крайна редица от елементи от един и същ тип. Операцията включване на елемент е допустима само за единия (например десния) край на редицата, който се нарича край на опашката. Операцията изключване на елемент е допустима само за другия (левия) край на редицата, който се нарича начало на опашката. Възможен е пряк достъп само до елемента, намиращ се в началото на опашката.
-	Физическо представяне: Аналогично на стека, при опашката се използват два основни начина за физическо представяне: последователно и свързано. При последователното представяне се запазва блок от паметта, вътре в който опашката да расте и да се съкращава. Свързаното представяне на една опашка е аналогично на това на стека, но се добавя още и указател към последния елемент на опашката.
9.	Структура от данни дърво:
-	Логическо описание: Нека Te е даден тип данни. Дърво от тип Te е структура, която е образувана от: • стойност от тип Te, наречена корен на дървото от тип Te; • крайно, възможно празно множество с променлив брой елементи – дървета от тип Te, наречени поддървета на дървото от тип Te.
-	Физическо представяне на дърво: Обикновено се използва свързаното представяне на дърво от тип Te, което се осъществява с помощта на свързан списък. При това физическо представяне в един свързан списък се реализират коренът и указателите към поддърветата на дървото от тип Te. Често се използват свързани представяния, основани на описание на дървото чрез задаване на неговите върхове и техните синове (върховете на дървото и техните родители). Тези представяния са най-характерни за езиците за програмиране от типа на Haskell.
10.	Основни дефиниции:
-	Лист (листо) на дадено дърво – това е корен на поддърво на разглежданото дърво, което няма поддървета. 
-	Връх (възел) – това е корен на поддърво. Върховете, които не съвпадат с корена и листата, се наричат вътрешни върхове. 
-	Родител (баща) на даден връх v – това е върхът p, който е такъв, че v е корен на поддърво на дървото с корен p. Коренът на дървото няма родител, а останалите му върхове имат точно по един родител (баща). 
-	Предшественици на даден връх са неговият родител (неговият баща) и предшествениците на неговия баща. Коренът на дървото няма предшественици.
-	Пряк наследник (син) на даден връх v е всеки връх, за който v е родител (баща). Листата на дървото нямат синове. 
-	Наследници на даден връх са неговите преки наследници (т.е. синовете му) и наследниците на неговите синове. Листата на дървото нямат наследници. 
-	Път в дървото се нарича всяка редица от вида n1, n2, … , nk от върхове на дървото, която е такава, че ni е родител (баща) на ni+1 (i = 1,2, … , k-1). 
-	Дължина на пътя n1, n2, … , nk, nk+1 е числото k (k≥0). 
-	Височина на едно дърво се нарича дължината на най-дългия път в дървото, свързващ корена и лист от това дърво.
11.	Алгебричните типове- са съставни типове данни, дефинирани от програмиста. Дефиницията на един алгебричен тип започва с ключовата дума data, след която се записват името на типа, знак за равенство и конструкторите на типа. Името на типа и имената на конструкторите задължително започват с главни букви. 
Примери: 1) data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
2) data Temp = Cold | Hot 
3) data Season = Spring | Summer | Autumn | Winter
12.  Производни типове- Вместо използването на вектори можем да дефинираме тип с определен брой компоненти като алгебричен тип. Такива типове често се наричат производни типове (резултатни типове; product types). 
Примери: 1) data People = Person Name Age 
Тук Name е синоним на String, а Age е синоним на Int: 
type Name = String 
type Age = Int
12.	Алтернативи- Геометричните фигури могат да имат различна форма, например кръгла или правоъгълна. Тези алтернативи могат да бъдат включени в дефиниция на тип от вида data Shape = Circle Float | Rectangle Float Float 
Дефиниция от вида на посочената означава, че съществуват два алтернативни начина за конструиране на елемент на Shape.
Дефиниции на функции върху типа Shape:
1)	isRound :: Shape -> Boo1
isRound (Circle _) = True
isRound (Rectangle _ _) = False
2)	area :: Shape -> Float
area (Circle r) = pi*r*r
area (Rectangle h w) = h*w
13.	Производни екземпляри на класове: Възможно е да се дефинира нов алгебричен тип като например Season или Shape, който да бъде екземпляр на множество вградени класове.
Примерни дефиниции от посочения вид:
1)data Season = Spring | Summer | Autumn | Winter
 deriving (Eq,Ord,Enum,Show,Read)
2)data Shape = Circle Float |
 Rectangle Float Float
 deriving (Eq,Show,Read)
14.	Рекурсивни алгебрични типове-  Често характерът на решаваните задачи е такъв, че е естествено някои от алгебричните типове, които потребителят дефинира, да се описват в термините на самите себе си. Такива алгебрични типове се наричат рекурсивни. Например понятието „аритметичен израз“ може да се дефинира или като литерал – цяло число, или като комбинация на два аритметични израза, в която се използва аритметичен оператор като + или –.
Примерна дефиниция на Haskell: data Expr = Lit Int | Add Expr Expr |Sub Expr Expr
Аналогично понятието „двоично дърво“ може да се дефинира или като nil, или като комбинация от стойност и две поддървета. Съответната дефиниция на Haskell изглежда по следния начин: data NTree = NilT | Node Int NTree Ntree. Тази дефиниция е подходяща за моделирането на двоични дървета от цели числа (двоични дървета от тип Int).
Дефиниции на някои функции за работа с двоични дървета от цели числа:
sumTree,depth :: NTree -> Int
sumTree NilT = 0
sumTree (Node n t1 t2) = n + sumTree t1 + sumTree t2
depth NilT = 0
depth (Node n t1 t2) = 1 + max (depth t1) (depth t2)
15.	Взаимно рекурсивни типове-  Често е полезно при описанието на един тип да бъдат използвани други типове. Някои от тези типове от своя страна биха могли да цитират първия. В такива случаи се говори за взаимно рекурсивни типове. Например описанието на даден възрастен човек може да включва биографични детайли, които биха могли да съдържат информация за други хора или поне да цитират други хора.
Примерни дефиниции от посочения вид: 1) data Person = Adult Name Address Biog | Child Name 2) data Biog = Parent String [Person] | NonParent String
16.	Полиморфни алгебрични типове- Дефинициите на алгебрични типове могат да съдържат променливи на типове (типови променливи, type variables) a, b и т.н. По този начин се дефинират полиморфни типове.
Пример:
data Pairs a = Pr a a
Примерни елементи на този тип:
Pr 2 3 :: Pairs Int
Pr [ ] [3] :: Pairs [Int]
Pr [ ] [ ] :: Pairs [a]
Дефиниция на функция, която проверява дали са равни двете
части на дадена двойка:
equalPair :: Eq a => Pairs a -> Bool
equalPair (Pr x y) = (x==y)
17.	Списъци- Вграденият списъчен тип може да бъде дефиниран като алгебричен например по следния начин: data List a = NilList | Cons a (List a) deriving (Eq,Show,Read) Тук синтаксисът [a], [ ] и ‘:’ е аналогичен на List a, NilList и Cons. Така типът „списък“ е добър пример за рекурсивен полиморфен тип.
18.	Двоични дървета-  Ако искаме да дефинираме двоично дърво от произволен тип a, това може да стане с помощта на конструкция от вида data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Eq,Show,Read). При това някои от вече дискутираните дефиниции на функции за работа с двоични дървета от цели числа могат да бъдат използвани и в общия случай, например: 
depth :: Tree a -> Int 
depth Nil = 0 
depth (Node n t1 t2) = 1 + max (depth t1) (depth t2)
Примери: 1) numberOfNodes :: Tree a -> Int
numberOfNodes Nil = 0
numberOfNodes (Node n leftTree rightTree) = 1 + numberOfNodes leftTree + numberOfNodes rightTree
2)	countLeaves :: Tree a -> Int 
countLeaves Nil = 0 
countLeaves (Node _ Nil Nil) = 1 
countLeaves (Node _ leftTree rightTree) = countLeaves leftTree + countLeaves rightTree
3)	mapTree :: (a -> b) -> Tree a -> Tree b 
mapTree f Nil = Nil 
mapTree f (Node x tl t2) = Node (f x) (mapTree f tl) (mapTree f t2)
19.	Една полиморфна функция, например length (намиране на дължина на списък, чийто елементи могат да бъдат от произволен тип), има единствена дефиниция, която работи върху всички нейни типове.
20.	Генеричните функции, например == (проверка за равенство), + (събиране на числа от един и същ тип) и show (конвертиране на число, булева стойност и др. в низ), могат да бъдат прилагани към данни от много типове, но за различните типове в действителност се използват различни дефиниции (различни методи на генеричната функция).
21.	С други думи, операторът + може да бъде прилаган към аргументи от всеки числов тип и резултатът от прилагането му ще бъде от същия тип. Тази идея може да бъде прецизирана с използване на т. нар. ограничение върху класа (class constraint) при дефинирането на типа на оператора +: (+) :: Num a => a -> a -> a. Горното ограничение означава, че за всеки тип a, който е екземпляр на класа Num на/от числови(те) типове, функцията (+) е от тип a -> a -> a.
Всеки тип, който включва едно или повече ограничения върху класа, се нарича overloaded (пренатоварен; додефиниран). Функция, чийто тип е додефиниран, се нарича генерична (додефинирана). Следователно, Num a => a -> a -> a е додефиниран тип и (+) е генерична (додефинирана) функция.
22.	Множеството (колекцията) от типове, за които са дефинирани съответно множество от функции, се нарича клас от/на типове (type class) или накратко клас. Например, множеството от типове, за които е дефинирана функцията за проверка на равенство (==), се означава като клас Eq.
23.	Дефиниране на класа Eq-  За да може да се дефинира един клас, е необходимо да се избере (зададе) неговото име и да се опишат ограниченията, които трябва да удовлетворява даден тип a, за да принадлежи на този клас. Типовете, които принадлежат на даден клас, се наричат екземпляри на този клас. Най-важно (определящо) за класа Eq е наличието на функцията == от тип a -> a -> Bool, която проверява дали два елемента на даден тип a, който е екземпляр на Eq, са равни: class Eq a where (==) :: a -> a -> Bool. Примери:
1)	allEqual :: Eq a => a -> a -> a -> Bool 
allEqual m n p = (m==n) && (n==p) 
2)	elem :: Eq a => a -> [a] -> Bool 
elem _ [] = False 
elem x (y:ys) = (x == y) || (elem x ys)
24.	дефиницията на даден клас- включва декларация от вида class Visible a where toString :: a -> String size :: a -> Int Декларацията включва името на класа (Visible) и т. нар. signature (сигнатура; „подпис“) на класа, т.е. списък от имената и типовете на функциите, които еднозначно определят (характеризират) класа – това са функциите, които следва задължително да бъдат дефинирани за всички типове, които са екземпляри на този клас.
25.	Дефиниране на екземпляри на клас- Един тип се определя като екземпляр на даден клас, като се дефинират функциите от сигнатурата на класа за елементите на този тип. Например дефиницията:1) instance Eq Bool 
where True == True = True 
False == False = True
 _ == _ = False   
 определя вградения тип Bool като екземпляр на класа Eq.
26.	Дефиниции по подразбиране- Нека отново се върнем към дефиницията на класа Eq. В Haskell този клас е дефиниран по следния начин: 
class Eq a where 
(==), (/=) :: a -> a -> Bool
 x /= y = not (x==y)
 x == y = not (x/=y) Към операцията за сравнение с цел проверка на равенство се добавя и проверката за неравенство (различие). Освен това са включени и дефиниции по подразбиране на /= чрез == и на == чрез /=.
27.	Производни класове- Езикът Haskell позволява да бъдат дефинирани класове, които са подкласове (производни класове, derived classes) на други класове. Най-прост пример в това отношение е класът на наредените типове, Ord. За да бъде нареден, един тип трябва да поддържа операциите за сравнение ==, /=, >, >=, <=. Наличието на първите две операции означава, че наредените типове образуват подмножество на класа Eq, т.е. те образуват подклас (производен клас, derived class) на класа Eq.
28.	Подобни множествени ограничения могат да се появят и в дефиницията на екземпляр, например instance (Eq a,Eq b) => Eq (a,b) where (x,y) == (z,w) = x==z && y==w Възможно е също множествени ограничения да бъдат включени в дефиницията на клас, например class (Ord a,Visible a) => OrdVis a В случаите, когато даден клас се дефинира на базата на два или повече класа, се казва, че е налице множествено наследяване (multiple inheritance).
29.	Ord – клас на наредените типове: Този клас включва типове, които са екземпляри на класа Еq, между елементите на които съществува (е дефинирана) линейна наредба, следователно техните елементи могат да бъдат сравнявани посредством следните методи: (<) :: a -> a -> Bool
(<=) :: a -> a -> Bool
(>) :: a -> a -> Bool
(>=) :: a -> a -> Bool
min :: a -> a -> a
max :: a -> a -> a
compare :: a -> a -> Ordering
30.	Enum – клас на изброимите типове: Дефиницията на този клас изглежда по следния начин:
class (Ord a) => Enum a where
 toEnum :: Int -> a
 fromEnum :: a -> Int
 enumFrom :: a -> [a] -- [n .. ]
 enumFromThen :: a -> a -> [a] -- [n,m .. ]
 enumFromTo :: a -> a -> [a] -- [n .. m]
 enumFromThenTo :: a -> a -> a -> [a] -- [n,n'.. m]
31.	Bounded – клас на ограничените типове: Този клас се специфицира посредством декларацията 
class Bounded a where 
minBound, maxBound :: a   ---Тук minBound и maxBound определят най-малката и найголямата допустима стойност на елементите на съответния тип.
32.	Show – клас на „видимите“ типове (типовете, чиито елементи могат да се преобразуват в символни низове) В стандартната прелюдия на Haskell e дефиниран класът Show, който съдържа всички типове, чиито елементи могат да се преобразуват в символни низове (и в този смисъл могат да бъдат визуализирани, т.е. по принцип са „видими“). Дефиницията на класа Show изглежда по следния начин:
type ShowS = String -> String
class Show a where
 showsPrec :: Int -> a -> ShowS
 show :: a -> String
 showList :: [a] -> ShowS
33.	Read – клас на типовете, чиито стойности могат да бъдат четени от низове Класът Read съдържа типове, чиито стойности могат да бъдат четени от символни низове. Като начало за използването на този клас е достатъчно да се познава функцията read :: (Read a) => String -> a Резултатът от изпълнението на тази функция може да не бъде добре дефиниран: необходимо е „входният“ низ да включва точно един обект от съответния тип.
34.	„Мързеливо“ оценяване (lazy evaluation)-  е стратегия на оценяване, която по стандарт стои в основата на работата на всички интерпретатори на Haskell. Същността на тази стратегия е, че интерпретаторът оценява даден аргумент на дадена функция само ако (и доколкото) стойността на този аргумент е необходима за пресмятането на целия резултат. Нещо повече, ако даден аргумент е съставен (например е вектор или списък), то се оценяват само тези негови компоненти, чиито стойности са необходими от гледна точка на получаването на резултата. При това дублиращите се подизрази се оценяват по не повече от един път.
Най-важно от гледна точка на оценяването на изрази в Haskell е прилагането на функции. Основната идея тук е еквивалентна на т. нар. оценяване чрез заместване в „традиционните“ езици за функционално програмиране. Оценяването на израз, който е обръщение към функцията f с аргументи a1, a2, … , ak, се състои в заместване на формалните параметри (променливите от образците, които играят ролята на формални параметри) от дефиницията на f съответно с изразите a1, a2, … , ak (или със съответните техни компоненти) и оценяване на така получения частен случай на тялото на дефиницията.
Ако например дефинираме
g x y = x + 12 , то
g (9-3) (g 34 3)
 (9-3) + 12
 6 + 12
 18      --  Тук x се замества с (9-3), но y не участва в дясната страна на равенството, определящо стойността на g, следователно аргументът (g 34 3) не се оценява. Така демонстрирахме едно от преимуществата на „мързеливото“ оценяване: аргументи, които не са необходими, не се оценяват. Последният пример не е особено смислен, тъй като вторият аргумент не се използва в никакъв случай и по същество е излишен в дефиницията на g.
Нека сега функцията h е дефинирана както следва:
h :: Int -> Int -> Int
h x y = x + x
Тогава
h (9-3) (h 34 3)
 (9-3) + (9-3)
 6 + 6
 12       --Изглежда, че в последния пример аргументът (9-3) се оценява двукратно, но принципите на „мързеливото“ оценяване гарантират, че дублираните аргументи (т.е. многократните включвания на аргументи) се оценяват по не повече от един път.
35.	Работа с безкрайни списъци в Haskell- Едно важно следствие от „мързеливото“ оценяване в Haskell е обстоятелството, че езикът позволява да се работи с безкрайни структури. Пълното оценяване на такава структура по принцип изисква безкрайно време, т.е. не може да завърши, но механизмът на „мързеливото“ оценяване позволява да бъдат оценявани само тези части („порции“) на безкрайните структури, които са реално необходими.
Най-прост пример за безкраен списък: безкраен списък от еднакви елементи, например безкраен списък от единици. ones :: [Int]; ones = 1 : ones Оценяването на ones ще продължи безкрайно дълго и следователно ще трябва да бъде прекъснато от потребителя. Възможно е обаче съвсем коректно да бъдат оценени обръщения към функции с аргумент ones.
36.	Основни дефиниции:  1)Граф Γ се нарича наредената двойка , където V = {a1,a2, … ,an} е множество, R е ненареден списък от двойки елементи на V. 2) Елементите на V се наричат върхове (възли) на графа Г, а елементите на R – ребра (дъги) на графа Г. 3) Ако ребрата на Г са наредени двойки, графът Г се нарича ориентиран; ако ребрата не са наредени, Г се нарича неориентиран граф. 
37.	Геометричното изображение на графите се получава, като: • изберем толкова различни точки, колкото върха има графът, и съпоставяме на всеки връх по една точка; • върховете ai и aj съединим с: o линия, ако графът е неориентиран и (ai,aj)  R; o стрелка, ако графът е ориентиран и (ai,aj)  R.
38.	Основно понятие в теорията на графите е понятието път. Под път в ориентиран граф се разбира всяка редица от ребра, имаща вида ai1,ai2  ,ai2,ai3 ….  ail,ai+1  . Ще казваме, че този път води от ai1 до ail+1 (има начало ai1 и край ail+1 ) и има дължина l. Под път в неориентиран граф се разбира всяка редица от ребра, имаща вида <a1,a2>,<b1,b2>…<e1,e2>,<l1,l2>,  където единият елемент на всяко ребро принадлежи на левия съсед, а другият елемент – на десния съсед. От крайните ребра се изисква само по един техен елемент да принадлежи на съседа на реброто. Другите два елемента определят краищата на пътя, а броят на ребрата – неговата дължина. 
Забележка. Често пътищата в графа се представят като поредици от участващите в тях (съставящите ги) върхове (възли). Път със съвпадащи краища (съвпадащи начало и край) се нарича цикъл. Път, който съдържа цикъл, се нарича цикличен; в противен случай пътят се нарича ацикличен. Графът Г= <V,R> се нарича краен, ако V и R са крайни.
39.	Основни стратегии на търсене на път в граф Общ алгоритъм за търсене: • Даден е граф; известни са началният възел (Start) и целевият възел (Goal); • Последователно се изследват пътищата от началния възел; • Поддържа се фронт/граница (frontier) от пътищата, които са били изследвани; • По време на процеса на търсене фронтът се разширява в посока към неизследваните възли, докато се достигне до целевия възел; • Начинът, по който фронтът се разширява, както и това, точно кой път от фронта се избира за разширяване на фронта на следващата стъпка, дефинира стратегията на търсене (search strategy).
40.	Търсене в дълбочина (depth-first search): • При търсенето в дълбочина фронтът се обработва като стек. • В началото на търсенето фронтът има вида [[Start]]. • Ако на текущата стъпка фронтът е празен ([ ]), търсенето се прекратява и се връща [ ] (индикация за липса на решение). • Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то: o избира се първият елемент на фронта (p1); o ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат; o ацикличните пътища p1', p1" , … , p1(k), които продължават с една дъга p1, се добавят в началото на стека (преди p2), т.е. фронтът придобива вида [p1', p1'', … , p1(k), p2, ... , pn] и се преминава към следващата стъпка; o p2 се обработва едва след като се изследват всички пътища, които са продължения на p1.
41.	Търсене в широчина (breadth-first search): • При търсенето в широчина фронтът се обработва като опашка. • В началото на търсенето фронтът има вида [[Start]]. • Ако на текущата стъпка фронтът е празен ([ ]), търсенето се прекратява и се връща [ ] (индикация за липса на решение). • Ако на текущата стъпка фронтът е [p1, p2, ... , pn], то: o избира се първият елемент на фронта (p1); o ако пътят p1 е достигнал целта, търсенето се прекратява и p1 се връща като резултат; o ацикличните пътища p1', p1" , … , p1(k), които продължават с една дъга p1, се добавят в края на опашката (след pn), т.е. фронтът придобива вида [p2, ... , pn, p1', p1'', … , p1(k)] и се преминава към следващата стъпка; o p1' се обработва едва след като се изследват всички пътища p2, ... , pn. • Намира най-краткия път от началния до целевия възел.
